---
title: COMP2521 Revision Theory Questions
date: 2023-07-29
desc: Theory based questions for the CSESoc COMP2521 Exam Revision Session.
tags:
  - 'COMP2521'
  - 'Exam Revision'
author: CSESoc  Education  Team
coverPhoto: '/images/generic/alexandru-acea-XEB8y0nRRP4-unsplash.jpg'
---

This page has a set of practice questions that cover most topics in COMP2521 23T3 and will give you a chance to test your knowledge of data structures and algorithms.

Note that the theory questions in the real COMP2521 23T3 exam will not be multiple choice!

<MultiChoice>
  <MultiChoice.Question>
    ## Question 1 - Minimum Spanning Tree
    
    Given this graph, find the total weight of the minimum spanning tree.

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/4-mst.png" alt="Graph" width="70%" />
    </Centerer>

  </MultiChoice.Question>
  <MultiChoice.Answer content="14" />
  <MultiChoice.Answer content="15" isCorrect>
    <MultiChoice.Explanation>
      Easier: Kruskal's algorithm

      Harder: Prim's algorithm

      Using principals of Kruskal's algorithm:

      A minimum spanning tree is a tree which contains all vertices, has no cycles, and has the smallest total weight of all possible spanning trees.
      Since we want the smallest total weight, start by adding the edge with the smallest weight into your MST graph. In this case, it is edge VW with weight 1.
      We then repeat the process for the next smallest edge: UW, RV, QR, or ST etc, continually adding them to your MST as long as the edge does not form a cycle. If the edge forms a cycle,
      move on to next smallest edge.

    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer content="16" />
  <MultiChoice.Answer content="18" />
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 2 - Graph Traversal Algorithms
    
    Consider the following iterative functions for breadth-first 
    and depth-first traversal on a graph.

    Show what would be printed by the following calls to
    these functions on this graph.

    When visiting neighbouring vertices, assume they are visited in ascending order.

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/bft-dft.png" alt="Graph" width="70%" />
    </Centerer>

    a) `breadthFirst(g, 3)`

    b) `depthFirst(g, 0)`

  </MultiChoice.Question>
  <MultiChoice.Answer>
    a) 3, 2, 0, 6, 5, 4, 1

    b) 0, 1, 5, 2, 3, 4, 6

  </MultiChoice.Answer>
  <MultiChoice.Answer isCorrect>
    a) 3, 0, 2, 1, 4, 5, 6

    b) 0, 1, 5, 2, 3, 6, 4
    <MultiChoice.Explanation>
      **a) Solution for breadth-first traversal**

      Given vertex v = 3, our breadthFirst traversal will begin at v = 3.

      Since vertex x = 3 has not been visited, it is printed as first element. The for loop
      then checks every vertex y from 0 to nV - 1.

      If y is connected to vertex x via
      an edge, and has not been visited, add y to queue.

      Since y = 0 and y = 2 are
      the only vertices which are connected to x = 3 and haven't been visited, add them to queue
      respectively.

      Vertex 0 is then dequeued, where x = 0 (note queue is a first in, first out ADT).

      Since vertex x = 0 has not been visited, it is
      printed as second element.

      The for loop then checks every vertex y from 0 to nV - 1.

      If y is connected to vertex x via
      an edge, and has not been visited, add y to queue.

      Since y = 1, y = 4, and y = 5 are
      the only vertices which are connected to x = 0 and haven't been visited, add them to queue
      respectively.

      This process is repeated until the queue is empty, and resulted in the vertices printed in this
      order: 3, 0, 2, 1, 4, 5.


      **b) Solution for depth-first traversal**

      Similar process to part a), except depthFirst() doesn't use a queue,
      but a stack (a first in, last out ADT).

      Another difference is that the for loop
      starts checking from the largest vertex nV - 1, to the smallest vertex 0.
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer>
    a) 3, 0, 1, 5, 2, 6, 4

    b) 0, 1, 5, 4, 2, 3, 6

  </MultiChoice.Answer>
  <MultiChoice.Answer>
    a) 0, 1, 5, 2, 4, 6, 3

    b) 3, 0, 1, 5, 2, 6, 4

  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 3 - Time complexity

    Find the Big-O time complexity of the following function in terms of n where n is the number of elements in the `nums` array.
    ```c:print_nums.c
    void print_nums(int nums[]) {
        for (int i = 0; i < 100; i++) {
            printf(""%d\n"", nums[i]);
        }
    }
    ```

  </MultiChoice.Question>
  <MultiChoice.Answer isCorrect>
    O(1)
    <MultiChoice.Explanation content="The loop runs a definitive number of times (100 times) no matter how large the `nums` array might be. So the function runs in O(100) which simplifies to O(1)."/>
  </MultiChoice.Answer>
  <MultiChoice.Answer isCorrect={false}>
    O(100)
    <MultiChoice.Explanation content="In Big-O notation, constant factors should be omitted."/>
  </MultiChoice.Answer >

<MultiChoice.Answer>
  O(n)
  <MultiChoice.Explanation content="The loop inside the function does not execute in the order of n times. No matter how many elements in the array, the loop only iterates 100 times!" />
</MultiChoice.Answer>
<MultiChoice.Answer content="O(n ^ 2)" />
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 4 - Euler paths 
    
    Does an Euler path/circuit exist for this graph?

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/1-euler.png" alt="Graph" width="70%" />
    </Centerer>

  </MultiChoice.Question>

  <MultiChoice.Answer
    isCorrect content="Has Euler path, has Euler circuit">
    <MultiChoice.Explanation>
    An Euler path is a path that uses every edge of a graph exactly once.
    An Euler circuit is a cycle that uses every edge of a graph exactly once.

    How to determine if a graph has an Euler path/circuit without actually finding the path/circuit:

    A graph has an Euler path if and only if:
        - It is connected
        - It has exactly zero or exactly two vertices that have an odd degree

    A graph has an Euler circuit if and only if:
        - It is connected
        - It has exactly zero vertices that have an odd degree ie all vertices have an even degree

    Think about why. What degree should the head, tail, and internal vertices have in order to form an Euler path/circuit?

      The degree of a vertex is the number of edges
      connecting it. Looking at this graph, we see:

      <table >
        <tr>
          <th>Node</th><th>Degree</th>
        </tr>
        <tr>
          <td>0</td><td>2</td>
        </tr>
        <tr>
          <td>1</td><td>4</td>
        </tr>
        <tr>
          <td>2</td><td>2</td>
        </tr>
        <tr>
          <td>3</td><td>4</td>
        </tr>
        <tr>
          <td>4</td><td>2</td>
        </tr>
        <tr>
          <td>5</td><td>4</td>
        </tr>
        <tr>
          <td>6</td><td>2</td>
        </tr>
        <tr>
          <td>7</td><td>4</td>
        </tr>
      </table>

      Notice that none of the nodes/vertices have an odd degree. So an Euler circuit does exist for this graph. And by extension so does an Euler path (as an Euler circuit is a special case of an Euler path where the start and end vertices are the same).
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
    <MultiChoice.Answer content="Has Euler path, has no Euler circuit"/>
    <MultiChoice.Answer content="Has no Euler path, has Euler circuit">
    <MultiChoice.Explanation>
      If a graph has an Euler circuit, that also counts as an Euler path as an Euler circuit is a special case of an Euler path where the start and end vertices are the same.
    </MultiChoice.Explanation>
    </MultiChoice.Answer>
    <MultiChoice.Answer content="Has no Euler path, has no Euler circuit"/>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 5 - Sorting
    
    In which of the following sorting algorithms is the performance for both sorted and reverse inputs slower than random inputs?

  </MultiChoice.Question>
  <MultiChoice.Answer content="Bubble sort">
    <MultiChoice.Explanation content="Bubble sort will perform with O(n) complexity in the sorted case, but O(n^2) in the reverse case."/>
  </MultiChoice.Answer>
  <MultiChoice.Answer content="Selection sort" >
    <MultiChoice.Explanation content="Selection sort performs equally in all cases." />
  </MultiChoice.Answer>
  <MultiChoice.Answer content="Naive quicksort" isCorrect>
    <MultiChoice.Explanation content="Naive quicksort will be consistently slow with sorted and reverse inputs at it chooses the least efficient pivot, but quicker for random inputs as the naive pivot is more likely to split the partitions more equally." />
  </MultiChoice.Answer>
  <MultiChoice.Answer content="Merge sort">
    <MultiChoice.Explanation content="Merge sort has the same time complexity for all cases." />
  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 6 - Time complexity
    
    Find the time complexity of this function in Big-O notation in terms of `n`.

    ```c:question2.c
    # Assume n is the size of the dynamically allocated array `arr`
    int function(int n, int* arr) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
              arr[i] += 1;
            }
        }

        int total = 0;
        for (int i = 0; i < n; i++) {
            total += arr[i];
        }
        return total;
    }
    ```

  </MultiChoice.Question>
  <MultiChoice.Answer content="O(n)" />
  <MultiChoice.Answer content="O(n^2)" isCorrect>
    <MultiChoice.Explanation>
      The first loop has a nested loop that iterates 0 times, then 1 time, then 2 times, etc. up to `n - 1` times.
      ```c:
          for (int i = 0; i < n; i++) {
              for (int j = 0; j < i; j++) {
                arr[i] += 1;
              }
          }
      ```
      This results in a total of 0 + 1 + 2 + ... + n - 1 = n(n - 1) / 2 = O(n^2) operations (using formula for arithmetic sum).

      The second loop iterates n times.

      ```c:
          for (int i = 0; i < n; i++) {
              total += arr[i];
          }
      ```

      Since O(n^2) dominates O(n), the function's overall time complexity is O(n^2).
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer content="O(n^2 + n)">
      <MultiChoice.Explanation>
          In Big-O notation, we focus on the dominant term, which represents the most significant factor affecting the growth rate of time complexity as the input size increases.
          
          In this case, the dominant term is O(n^2), so we can ignore O(n) term which becomes insignificant for larger n.
      </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer content="O(n log(n))" />
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 7 - Time complexity

    Find the time complexity of this function in Big-O notation in terms of `n`.

    ```c:halve.c
    # Assume n >= 0
    void halve(int n) {
        if (n == 0) {
            return;
        }
        halve(n / 2);
    }
    ```

  </MultiChoice.Question>
  <MultiChoice.Answer content="O(1)"/>
  <MultiChoice.Answer isCorrect>
    O(log(n))
    <MultiChoice.Explanation>
    The value of `n` is halved at each step, hence is reduced to 0 in a logarithmic fashion.
    </MultiChoice.Explanation>
  </MultiChoice.Answer>
  <MultiChoice.Answer content="O(n)" />
  <MultiChoice.Answer content="O(2 ^ n)"/>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 8 - Time complexity

    Find the time complexity of this function in Big-O notation in terms of `n` and `m`.

    ```c:rem.c
    # Assume n > m > 0
    int rem(int n, int m) {
      while (n >= m) {
          n -= m;
      }
      return n;
    }
    ```

  </MultiChoice.Question>
  <MultiChoice.Answer content="O(n + m)"/>
  <MultiChoice.Answer content="O(n - m)" />
  <MultiChoice.Answer content="O(n * m)"/>
  <MultiChoice.Answer isCorrect>
    O(n / m)
    <MultiChoice.Explanation>
    This function is used to find the remainder after dividing `n` by `m`. The number of steps will be how many times `m` goes into `n`.
    </MultiChoice.Explanation>
  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 9 - AVL Trees

    After inserting `45` into this AVL tree, what will the tree look like?

    <Centerer>
    <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-basic.png" alt="Graph" width="100%" />
    </Centerer>

  </MultiChoice.Question>
  <MultiChoice.Answer>
    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-a.png" alt="Graph" width="100%" />
    </Centerer>
    <MultiChoice.Explanation content="In an AVL tree we must maintain the height-balance imperative after each insertion -- every node must be height-balanced. I.e. for each node, the difference in height of it's left and right subtrees must be less than 2." />
  </MultiChoice.Answer>
  <MultiChoice.Answer>
    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-b.png" alt="Graph" width="100%" />
    </Centerer>
    <MultiChoice.Explanation content="We cannot insert the 45 directly as the right child of 43 and push the 67 out of place." />
  </MultiChoice.Answer>
  <MultiChoice.Answer>
    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-c.png" alt="Graph" width="100%" />
    </Centerer>
    <MultiChoice.Explanation content="Right rotation about 67 from the original tree. This is part of the solution, but not complete as the tree is still unbalanced (at node 43)." />
  </MultiChoice.Answer>
  <MultiChoice.Answer isCorrect>
    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-e.png" alt="Graph" width="100%" />
    </Centerer>
    <MultiChoice.Explanation>
      Firstly we insert the new node 45 into it's correct position in the binary search tree.

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-explanation-1.png" alt="Graph" width="100%" />
    </Centerer>

      To maintain the height-balance imperative of an AVL tree, we unwind along the path from the new node back up to the root, checking the balance of each node. We find that the node 43 is unbalanced:

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-explanation-2.png" alt="Graph" width="100%" />
    </Centerer>

      Since the new node 45 went to the right of 43, then to the left of 67, we need to do a double rotation to balance the tree. We first do a right rotation on 67, then a left rotation on 43:

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-explanation-3.png" alt="Graph" width="100%" />
    </Centerer>

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-explanation-4.png" alt="Graph" width="100%" />
    </Centerer>

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q10-avl-explanation-5.png" alt="Graph" width="100%" />
    </Centerer>

      Node 55 becomes the new root and our AVL tree is once again fully height-balanced after the insertion of 45.
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 10 - BFS and DFS

    What is the difference between the implementation of iterative BFS and iterative DFS and the theoretical difference between the two?

  </MultiChoice.Question>
  <MultiChoice.Answer isCorrect>
    BFS uses a queue, checking all neighbours of a node before moving on to another node, and DFS uses a stack, checking every new node as it is found.

    <MultiChoice.Explanation>
      BFS uses a queue to store the next node to be explored. This makes it so that when a node is visited, we add all its neighbours to the queue and when we check through the queue, we check all the most recently added nodes, i.e., all the added neighbours of a node, before we move further down the graph.

      DFS uses a stack, meaning we explore by checking the most recently added node to the stack. This means we will keep checking the most recently added node before we check previously added nodes, meaning we will keep going though the tree until we hit the end before we check a particular nodes neighbours.
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer content="BFS uses a stack, checking all neighbours of a node before moving on to another node, and DFS uses a queue, checking every new node as it is found."/>
  <MultiChoice.Answer content="BFS uses a queue, checking every new node as it is found, and DFS uses a stack, checking all neighbours of a node before moving on to another node."/>
  <MultiChoice.Answer content="BFS uses a stack, checking every new node as it is found, and DFS uses a queue, checking all neighbours of a node before moving on to another node."/>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 11 - Graph ordering

    Which of the following is post order?

  </MultiChoice.Question>
  <MultiChoice.Answer>
    1. Traverse the left subtree, i.e., call recursion (left-subtree).
    
    2. Visit the root (i.e., do work on the current node).
    
    3. Traverse the right subtree, i.e., call recursion (right-subtree).
  </MultiChoice.Answer>

  <MultiChoice.Answer>
    1. Visit the root (i.e., do work on the current node).

    2. Traverse the left subtree, i.e., call recursion (left-subtree).

    3. Traverse the right subtree, i.e., call recursion (right-subtree).

  </MultiChoice.Answer>

  <MultiChoice.Answer isCorrect>
    1. Traverse the left subtree, i.e., call recursion (left-subtree).

    2. Traverse the right subtree, i.e., call recursion (right-subtree).

    3. Visit the root (i.e., do work on the current node).
    <MultiChoice.Explanation>
      For Inorder, you traverse from the left subtree to the root then to the right subtree.

      For Preorder, you traverse from the root to the left subtree then to the right subtree.

      For Post order, you traverse from the left subtree to the right subtree then to the root.
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer>
    None of the above.
  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 12 - Tree Rotations

    What sequence of rotations will transform this tree to end up with 7 at the root?

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/rotate-7-base.png" alt="Graph" width="60%" />
    </Centerer>

  </MultiChoice.Question>
  <MultiChoice.Answer content="rotate_right(7), rotate_left(8), rotate_right(5)" />
  <MultiChoice.Answer content="rotate_left(8), rotate_right(5), rotate_left(10)" />
  <MultiChoice.Answer content="rotate_left(5), rotate_right(8), rotate_right(8)"/>
  <MultiChoice.Answer isCorrect>
    rotate_right(8), rotate_left(5), rotate_right(10)
    <MultiChoice.Explanation>
      Rotating right on node 8 brings the 7 up to 8's position. Then we rotate left on the 5 to bring up the 7 again and finally rotate right on 10 to push the 7 into the root position.
    </MultiChoice.Explanation>
  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 13 - Kruskal's Algorithm

    Using Kruskal's algorithm, find the minimum spanning tree of this fully connected and weighted graph.

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/kruskal.png" alt="Graph" width="70%" />
    </Centerer>

    During this procedure, how many times do you encounter a cycle before you find the MST?

  </MultiChoice.Question>

  <MultiChoice.Answer content="0" />
  <MultiChoice.Answer content="1" />
  <MultiChoice.Answer content="2" />
  <MultiChoice.Answer isCorrect>
    3
    <MultiChoice.Explanation>
      The Kruskal's algorithm is a greedy algorithm that finds the minimum spanning tree of a graph. It works by choosing edges in sorted order by lowest weight (unless it forms a cycle) until all vertices are included.

      Let's walk through applying Kruskal's algorithm to the graph.

      We start with an empty set of edges which represents the MST we want to build. We also keep a count of the number of vertices that have been included in the MST so we can stop when we have included all vertices.

      We sort the existing edges in the graph by weight and start to choose them by lowest weight edge to add to the MST.

      We choose the first edge E-G with weight 1 and add it to our MST. We then check that our new MST does not form a cycle after this addition and keep the edge.

      ![Imgur](https://i.imgur.com/tQxZSzH.png)

      Next add the edge G-F with weight 2 to our MST. We check that it does not form a cycle and keep the edge.

      ![Imgur](https://i.imgur.com/1DgtJGV.png)

      Next add the edge A-C with weight 3 to our MST. We check that it does not form a cycle and keep the edge.

      ![Imgur](https://i.imgur.com/pWk6eb2.png)

      Next add the edge E-F with weight 4 to our MST. We find that after this addtion our MST now has a cycle, so we remove the edge.

      ![Imgur](https://i.imgur.com/te21CM1.png)

      Next add the edge E-D with weight 5 to our MST. We check that it does not form a cycle and keep the edge.

      ![Imgur](https://i.imgur.com/ruMBsMN.png)

      Next we find two edges with the same weigth 6: A-D and F-D. We can choose these edges to add to the MST in arbitrary order since it would not make a difference to the minimum weight of our MST.

      We'll add the edge A-D first. We check that it does not form a cycle and keep the edge.

      ![Imgur](https://i.imgur.com/mED0IRd.png)

      Next we add the edge F-D; the remaining edge with weigth 6. We find that after this addtion our MST now has a cycle, so we remove the edge.

      ![Imgur](https://i.imgur.com/zNM0uo2.png)

      Next add the edge C-F with weight 7 to our MST. We find that after this addtion our MST now has a cycle, so we remove the edge.

      ![Imgur](https://i.imgur.com/Zk0qOEl.png)

      Next we add the edge A-B with weight 8 to our MST. We check that it does not form a cycle and keep the edge.

      ![Imgur](https://i.imgur.com/KSTqyfQ.png)

      At this point our MST contains all the vertices from the original graph, and hence we have found the minimum spanning tree.

      To answer the question, there were three instances where we added an edge and found that it formed a cycle in our MST.
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 14 - Tree Rotations

    Which sequence of transformations will make the following transformation?

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/rotate-seq-base.png" alt="Graph" width="60%" />
    </Centerer>

    <Centerer>
      <ArrowDown size={32}/>
    </Centerer>

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/rotate-seq-after.png" alt="Graph" width="60%" />
    </Centerer>

  </MultiChoice.Question>
  <MultiChoice.Answer content="rotate_right(1), rotate_left(7)" />
  <MultiChoice.Answer isCorrect>
    rotate_right(2), rotate_left(6)
    <MultiChoice.Explanation>
      Rotating shifts the root node in the direction of the rotation. Hence as 2 moves down to the right, we do rotate_right(2).

      Similar logic can be applied for rotate_left(6).
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer content="rotate_right(5), rotate_left(3)"/>
  <MultiChoice.Answer content="rotate_right(6), rotate_left(2)" />
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 15 - Dijkstra's Algorithm (Challenge)

    Using Dijkstra's algorithm, find the shortest path from A to all other vertices in this fully connected directed and weighted graph.

    <Centerer>
      <img style={{maxWidth: '500px'}} src="/images/comp2521-revision/q11-dijk.png" alt="Graph" width="70%" />
    </Centerer>

    During this procedure, how many times is an edge relaxed towards vertex E? In other words, on how many occasions do we update our knowledge of the shortest distance from A to E?

  </MultiChoice.Question>
  <MultiChoice.Answer content="0"/>
  <MultiChoice.Answer content="1"/>
  <MultiChoice.Answer isCorrect>
    2
    <MultiChoice.Explanation>
      Visit [here](https://gist.github.com/dqna64/e8c09e5a49630886692c9dac4f215688) for an explanation as to how to get this answer.
    </MultiChoice.Explanation>
  </MultiChoice.Answer>
  <MultiChoice.Answer content="3"/>
</MultiChoice>

<MultiChoice>
  <MultiChoice.Question>
    ## Question 16 - Time complexity (Challenge)

    What is the time complexity of the following function?

    ```c:print_pairs.c
    # Assume n > 0
    void print_pairs(int n) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j += i) {
                printf("%d %d\n", i, j);
            }
        }
    }
    ```

  </MultiChoice.Question>
  <MultiChoice.Answer content="O(n)"/>
  <MultiChoice.Answer isCorrect>
    O(n * log(n))
    <MultiChoice.Explanation>
      We firstly know that we will iterate through the outside loop `n` times, that gives us our `n` value.

      The number of iterations of the inside loop is reduced on every iteration of `i`, hence the number of inside loop iterations is being reduced in a logarithmic fashion.

      The outer loop runs `n` times. The inner loop runs `n, n/2, n/3, n/4, ...` times which is known as a <a href="https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)" target="_blank">harmonic series</a>. The total number of iterations is `n + n/2 + n/3 + ... + n/n = n * (1 + 1/2 + 1/3 + ... + 1/n)`. The series 1 + 1/2 + 1/3 + ... + 1/n is the nth harmonic number, and as n approaches infinity, the nth harmonic number approaches log(n). Therefore, the overall time complexity is O(n * log(n)).

      Note: you are not expected to know about harmonic series for the COMP2521 exam.
    </MultiChoice.Explanation>

  </MultiChoice.Answer>
  <MultiChoice.Answer content="O(n^1.5)" />
  <MultiChoice.Answer content="O(n^2)"/>
</MultiChoice>

Good luck for the exam! Remember; you've been preparing for it for the entire term so all that's left is to apply everything you've learned and to do your best :D
